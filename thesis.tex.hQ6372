% !TeX document-id = {5f9589b8-498a-4233-98c1-605de3ca7afa}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]


\documentclass[12pt, paper=a4, bibtotoc, toc=listof]{scrreprt}
\setcounter{tocdepth}{3}% Include \subsubsection in ToC
\setcounter{secnumdepth}{3}% Number \subsubsection
\setuptoc{toc}{numbered} % Adds ToC to ToC toDo: remove Pagenumber of ToC in ToC

\usepackage[ngerman]{babel} %Deutsch

\usepackage[utf8]{inputenc} %UTF8 Formatierung

\usepackage[T1]{fontenc}

\usepackage{helvet} %Arial
\renewcommand{\familydefault}{\sfdefault} %Arial

\usepackage{float}
\newfloat{listing}{tbhp}{lst}%[section]
\floatname{listing}{Listing}
\newcommand{\listoflistings}{\listof{listing}{Listing Verzeichnis}}

\usepackage{chngcntr}% http://ctan.org/pkg/chngcntr
\counterwithin{listing}{chapter} %counts chapters of listing




\usepackage[chapter]{minted} %Code Formatierung
\newminted{JavaScript}{frame=single,framesep=10pt}
\newminted{HTML}{frame=single,framesep=10pt, linenos}

\usepackage{caption}
\DeclareCaptionFont{black}{\scriptsize\color{black}}
\DeclareCaptionFormat{listing}{{\parbox{\linewidth-2\fboxsep}{#1#2#3}}}
\captionsetup[listing]{labelfont=black,textfont=black} %Caption of Listing
\captionsetup[figure]{labelfont=black,textfont=black} %Caption of Figure

\usepackage{graphicx} %IMG

\usepackage{csquotes}

\usepackage[onehalfspacing]{setspace} %Zeilenabstand


\usepackage[
	backend=biber,
	style=numeric
	]{biblatex}
\addbibresource{library.bib}

\usepackage{acronym}


% Neues cite-Kommando oder altes \footcite-Kommando überschreiben
\DeclareCiteCommand{\smfootcite}[\mkbibfootnote]
{\usebibmacro{prenote}}                                 
{\usebibmacro{citeindex}%
	\setunit{\addnbspace}
	\printnames{labelname}%
	\setunit{\labelnamepunct}
	\newunit
	\printfield{year}
}
{\addsemicolon\space}
{\usebibmacro{postnote}}


\title{Erstellung von adaptiven Web Components}
\author{Christoph Kleber}
\date{\today}

\begin{document}

	\maketitle
	
	\chapter*{Kurzfassung}
	\addcontentsline{toc}{chapter}{Kurzfassung}
	In dieser Arbeit geht es um Web Components.
	
	\chapter*{Abstract}
	\addcontentsline{toc}{chapter}{Abstract}
	
	This thesis is about Web Components.
	\listoflistings
	\listoffigures
	\chapter*{Abkürzungsverzeichnis}
	\addcontentsline{toc}{chapter}{Abkürzungsverzeichnis}
		\begin{acronym}
		\acro{API}{Advanced Programming Interface}
		\acro{DOM}[DOM]{Document Object Model}
		\acro{HTML}[HTML]{Hypertext Markup Language}
		\acro{URL}[URL]{Uniform Resource Locator}
		\acro{div}[div]{division}
		\acro{HTML5}[HTML5]{Hypertext Markup Language Version 5}
		\acro{CSS}[CSS]{Cascading Style Sheets}
		\acro{W3C}{World Wide Web Consortium}
	\end{acronym}

	\tableofcontents
	

	\chapter{Adaptivität}
		\section{Begriffsklärung}
			Das ist erster Text
			Test
	

		\section{Adaptivität bei User Interfaces}
	\chapter{Web Components}
		\section{Was sind Web Components}
		\emph{Web Components} sind eine \ac{W3C} Spezifikation. Diese soll es ermöglichen, eigenständige und wiederverwertbare Komponenten für Web Anwendungen zu erstellen. \smfootcite[ vgl.][S. 1]{patel2015learning} Sie setzen sich zusammen aus den vier Technologien \emph{Custom Elements}, \emph{\ac{HTML} Imports}, \emph{Templates} und \emph{Shadow \ac{DOM}}. Das Nutzen dieser Technologie soll Applikationen im Web leichter wiederverwertbar, wartbar, unabhängiger und kapselbar machen.\smfootcite[ vgl.][S. 2]{patel2015learning}
		\section{Geschichte von Web Components}
		\label{ref:gesVonWebCom}
		\emph{Web Components} wurden vom \ac{W3C} das erste Mal im Jahr 2012 erwähnt. Hier wurde es auch \emph{Component model for the web} genannt und bestand aus den vier Technologien \emph{Templates}, \emph{Decorators}, \emph{Custom Elements} und \emph{Shadow DOM}. In der derzeitigen Version der \emph{Web Components} wird die \emph{Decorators} Technologie nicht mehr verwendet und stattdessen wird die \emph{\ac{HTML} Import} Technologie verwendet.\smfootcite[ vgl.][]{Cooney2012} Da die \emph{Web Components} aus verschiedenen Technologien zusammengesetzt sind, wird in dem nächsten Abschnitt auf die Geschichte der einzelnen Technologien eingegangen, um einen Überblick zu verschaffen. Hierbei wird insbesondere auf die erste Unterstützung der Technologien in den verschiedenen Browsern eingegangen.
		\subsection{Custom Elements !v0 und v1!}
		\emph{Custom Elements} liegen in der Version v0 und in der Version v1 vor. Die Version v0 wurde das erste Mal im Jahr 2014 von den Browsern \emph{Chrome} in der Version 33 und \emph{Opera} in der Version 20 unterstützt. In den mobilen Varianten dieser Browser  wird sie seit 2016 von \emph{Opera for Android} in der Version 37 und von \emph{Chrome for Android} in der Version 53 unterstützt.\smfootcite[ vgl.][]{C2015} Im \emph{Android} Browser wird diese Version schon seit 2014 unterstützt, in der \emph{Android} Version 4.4.4. Im \emph{Samsung Internet} werden sie seit 2016 in der Version 4 genutzt.\smfootcite[ vgl.][]{cusEleCanIUse} Die Version v0 wird von der Version v1 abgelöst, hier ergeben sich einige Änderungen in der Syntax der \ac{API}.\smfootcite[ vgl.][]{Bidelman2016cusElev1} Derzeit wird sie nicht per Standardeinstellung von anderen Browsern unterstützt.\smfootcite[ vgl.][]{firefox} Die Version v1 wird derzeit nur von den Browsern \emph{Chrome} und \emph{Opera} unterstützt. Das erste mal wurde sie im Jahr 2016 in der \emph{Chrome} Version 54 und in der \emph{Opera} Version 41 genutzt. \smfootcite[ vgl.][]{C2016}
		\subsection{HTML Imports}
		HTML Imports wurden in den Browsern \emph{Chrome} und \emph{Opera} zuerst 2014 unterstützt. Die Imports wurden als Erstes in der \emph{Chrome} Version 36 und in der \emph{Opera} Version 23 genutzt. Gegenwärtig wird die Technologie von den zuvor erwähnten Browsern auch in den mobilen Browser-Varianten unterstützt, in den Versionen 53 des \emph{Chromium} und 37 des \emph{Opera for Android}.\smfootcite[ vgl.][]{Morrita2015} Der \emph{Android} Browser unterstützt \emph{HTML Imports} seit 2016 in der Version 53. Der Browser des \emph{Android} Betriebssystems ist ab dem Jahr 2016 in der Version 53 kongruent mit dem Chromium Browser. \emph{Samsung Internet} unterstützt die Imports seit 2016 in der Version 4.\smfootcite[ vgl.][]{htmlTemplCaniuse}
		\subsection{Decorators}
		\emph{Decorators} erscheinen nur in Dokumenten und Artikeln, sie werden nie von Browsern implementiert. So wird im Jahr 2012 in einem \emph{Working Draft} des \ac{W3C} von einem Beispiel gesprochen: \enquote{Here is an example of how decorators could be used to implement a simple variant of the details element}.\smfootcite[ ][]{Cooney2012} Dies zeigt, dass an dieser Stelle noch keine Implementierung dieser Technologie vorliegt. Auch in einem \emph{Working Draft} des \ac{W3C} vom Jahr 2013 wird davon gesprochen, dass \enquote{Decorators, unlike other parts of Web Components, do not have a specification yet.}\smfootcite[][]{Cooney2013}
		Auf einer aktuellen Übersichtsseite des Konsortiums wird die \emph{Decorators} Technologie nicht mehr im Zusammenhand mit \emph{Web Components} erwähnt.\smfootcite[ vgl.][]{WebComCur2016}
		\subsection{Templates}
		\emph{Templates} werden schon über einen längeren Zeitraum in den verschiedenen Browsern unterstützt. Zuallererst wurden sie im \emph{Chrome} im Jahr 2013 verwendet, in der Version 26. Im selben Jahr wurden sie vom \emph{Firefox} Browser in der Version 22 und vom \emph{Opera} Browser in der Version 15 unterstützt.\smfootcite[ vgl.][]{W2015}\smfootcite[ vgl.][]{htmlTemFire}
		Im Jahr 2015 wurden sie dann vom \emph{Edge} Browser unterstützt, in der Version 13.\smfootcite[ vgl.][]{build10547}
		Auf den Browsern des \emph{Macintosh} Betriebssystems wurden \emph{Templates} zuerst 2014 verwendet, in der \emph{Safari} Version 7.1 und der \emph{Safari \& Chrome for iOS} Version 8.\smfootcite[ vgl.][]{htmlTemplCaniuse} In den meisten mobilen Varianten der Browser werden Templates seit 2016 bereitgestellt. So erschien dieses Feature in dem \emph{Opera for Android} Browser in der Version 37, in \emph{Chrome for Android} in 53, in \emph{Firefox for Android} in 49 und im \emph{Samsung Internet} Browser in der Version 4. Der Standard Android Browser unterstützt Templates jedoch schon seit 2013, seit der Version 4.4\smfootcite[ vgl.][]{htmlTemplCaniuse}
		\subsection{Shadow DOM}
		Der \emph{Shadow \ac{DOM}} existiert in der Version v0 und in der Version v1. Die Version v0 wird seit 2014 vom \emph{Chrome} in der Version 35 und \emph{Opera} Browser in der Version 21 unterstützt. Mit Safari Version 10 kann der \emph{Shadom \ac{DOM}} seit 2016  genutzt werden.\smfootcite[ vgl.][]{NiwaShaDom} Die mobilen Varianten der Browser unterstützen das \emph{Shadow \ac{DOM}} seit 2016, \emph{Opera} in der Version 37 und \emph{Chrome} in der Version 53, somit auch der \emph{Android} Browser.\smfootcite[ vlg.][]{Hayato2016} Die Version v0 wird von der Version v1 abgelöst, welche verschiedene Neuerungen in der Syntax, aber auch in der Unterstützung von bestimmten Funktionen aufweist. So kann beispielsweise in der v0 ein \emph{shadow root} immer nur als \enquote{open} definiert werden, in der v1 kann er auch als \enquote{closed} \emph{shadow root} erstellt werden.\smfootcite[ vgl.][]{Ito2016}
		Die Version v1 wird noch nicht so großem Ausmaß wie die Version v0 unterstützt. Vollständig wird sie nur vom \emph{Chrome} 53 und \emph{Opera} 40 Browser unterstützt, jeweils seit 2016. In den mobilen Versionen wird sie nur von dem \emph{Chromium} und somit auch auf \emph{Android} in der Version 53 unterstützt.\smfootcite[ vlg.][]{Hayato2016a}
		\section{Vergleich Webentwicklung mit Web Components und ohne}
			Webapplikationen basieren auf vielen verschiedenen Technologien, beispielsweise \ac{HTML}, \ac{CSS} und \emph{JavaScript}. Meistens werden darüber hinaus noch verschiedene \emph{Frameworks} verwendet. \enquote{A computer system framework has a layered structure that can incorporate servers, operating systems, client machines, and applications. The framework can provide a set of functions to definde application interfaces, the interrelationships between applications, and internal communications between clients and external to online platforms}.\smfootcite[][S. 15]{stuart2013roadmap} Ein \emph{Framework} ist somit ein System, das den Entwicklern bestimmte Funktionalitäten zur Verfügung stellt, ohne dass dieser sie selbst programmieren muss. Diese können beispielsweise die Hilfe bei der Interaktion mit dem \ac{DOM} sein, wie das \emph{JavaScript Framework} \enquote{jQuery}, ein Slide-Element bereitstellen wie das \emph{Framework} \enquote{Slider} oder das Backend einer Webseite definieren wie das \emph{Framework} \enquote{TYP03 CMS}. Hier ergibt sich großes ein Problem. Wenn in einer Applikation mehrere \emph{Frameworks} und Technologien für verschiedene Funktionen verwendet werden, können diese sich gegenseitig beeinflussen. So können die \emph{Style} Regeln verschiedener Teile der Webseite sich unbeabsichtigt beeinflussen oder das \emph{JavaScript}, welches eine bestimmte Funktion hat, an einer anderen Stelle für welche es nicht programmiert wurde, Einfluss nehmen. Darüber hinaus können viele Teile der Webseite weder wiederverwendet, noch gut gewartet werden können, da sie großen Einfluss aufeinander nehmen und somit sehr ineinander verschachtelt sind.
			Die \emph{Web Components} versuchen diese Probleme durch eine (in Zukunft) native Implementierung verschiedener Techniken anzugehen, welche eine Kapselung, eine Wiederverwendung und eine leichtere Wartbarkeit von Programmcode ermöglichen.			
			\subsection{Vorteil: Wenn Browserunterstützung gegeben: native, kein Framework}
			Wenn es in der Zukunft der Fall sein wird, dass \emph{Web Components} nativ von allen Browsern unterstützt werden, ergibt sich daraus ein großer Vorteil. Es muss bei der Nutzung nativer, also von den Browsern implementierten Techniken, kein externer Programmcode genutzt werden um bestimmte Funktionen abzudecken. Viele Funktionalitäten können einfach über die Nutzung nativer Methoden abgebildet werden. Deshalb müssen weniger Funktionen selbst geschrieben werden und weniger, beziehungsweise unter Umständen keine \emph{Frameworks} genutzt werden. Dies verkleinert das Laden von externen Programmcode. Darüber hinaus ist die Syntax und Funktionsweise bei nativen Funktionen bekannt und eindeutig. Daraus ergeben sich weniger Inkonsistenzen in der Programmierung und eine leichtere Verständlichkeit. Im Gegensatz dazu muss bei vielen \emph{Frameworks} eine jeweils eigene Syntax benutzt werden.
			\subsection{Kapselung}
			Ein Mechanismus zur Datenkapselung wird vom \emph{Shadow DOM} bereitgestellt.
			Dieser ermöglicht, dass der Programmcode des \emph{Web Components} vom Rest der Applikation getrennt werden kann. Dadurch wird ein privater \emph{Scope}, also ein Geltungsbereich der Applikation und dessen Variablen, Methoden, Bezeichnern und ähnliches, genutzt.\smfootcite[ vgl.][S.2]{patel2015learning} Dies hat einige Folgen für das Verhalten einer Applikation. Zuerst ist der \emph{Shadow \ac{DOM}} isoliert, er kann nicht von außerhalb angesprochen werden, beispielsweise über die Funktion \emph{document.querySelector()}. Dies hat den Vorteil, dass die Funktionalität des \emph{Web Component} nicht von außen beeinträchtigt werden kann. Des weiteren hat das \ac{CSS} nur Zugriff auf den \ac{DOM} des eigenen Geltungsbereichs, weder von außerhalb des \emph{Shadow \ac{DOM}} können \emph{Style} Regeln Einfluss auf diesen nehmen, noch können \emph{Style} Regeln von innerhalb nach außen Einfluss nehmen. Ein Vorteil an dieser Eigenschaft ist, dass man atomare, also sehr einfache, \ac{CSS} Bezeichner innerhalb des \emph{Shadow \ac{DOM}} verwenden kann und dieselben Bezeichner gleichzeitig außerhalb dieses nutzen kann.\smfootcite[ vgl.][]{Bidelman2016} Darüber hinaus wird das \emph{Styling} der Applikation konsistenter, es erfolgt einzeln für jede \emph{Web Component} und für den Bereich außerhalb der \emph{Web Components}.
			\subsection{Wiederverwendung}
			Die Theorie der \emph{Web Components} ist die Erstellung von verschiedenen Komponenten, die immer wieder wiederverwendet werden können. Dies hat zum einen den großen Vorteil, dass es eine Interoperabilität zwischen \emph{Frameworks} ermöglicht.\smfootcite[ vgl.][S.2]{patel2015learning} Dadurch ist man nicht an ein bestimmtes \emph{Framwork} gebunden und kann auch mit außerhalb dieses Ökosystems interagieren und Komponenten wiederverwenden. Zum anderen können auch innerhalb eines \emph{Frameworks} oder nativ, ohne das Nutzen eines \emph{Frameworks}, Teile einer Anwendung wiederverwendet werden, was eine Arbeitserleichterung und Verminderung des Programmcodes hervorruft. 
			\subsection{Wartbarkeit}
			Die Wartbarkeit von Web-Applikationen wird erleichtert, da die \emph{Web Components} in \emph{Templates} organisiert sind.\smfootcite[ vgl.][S.2]{patel2015learning} Das sorgt dafür dass der Programmcode einzelner Komponenten separat gespeichert wird und somit leichter wiedergefunden und geändert werden kann.
			\subsection{Nachteil: Browserunterstützung}
			Auch wenn \emph{Web Components} sehr viele Vorteile aufweisen, ist es ein Problem wenn die Techniken nicht in allen Browsern unterstützt werden oder unterschiedlich implementiert sind. Wie in Kapitel \ref{ref:gesVonWebCom} dargelegt, sind einige der Techniken noch nicht von allen Browsern unterstützt, oder unterscheiden sich in deren Ausführung. Dies kann zu Inkonsistenzen oder dem nicht funktionieren einer Applikation führen. Dies kann jedoch umgangen werden, indem \emph{Polyfills} verwendet werden. Das sind in diesem Zusammenhang Programmcodes, welche die Funktionen oder Teile einer Technologie, die nativ noch nicht von einem Browser unterstützt wird, nachstellen. Diese können dann verwendet werden um Nutzern aller Browser die Technologien gebrauchen zu lassen.\smfootcite[ vgl.][S. 4 ]{satrom2014building} Das \emph{webcomponents.js} ist ein Set von \emph{Polyfills} und ermöglicht den Nutzern die Verwendung von \emph{Web Components} in allen modernen Browsern.\smfootcite[ vgl.][]{webComJs}
			
		\section{Technik der Web Components}
			\subsection{Custom Elements}
			Das \emph{Custom Element} ist eine \emph{\ac{API}}, welches das Bilden eigener, voll funktionstüchtiger \emph{\ac{DOM}} Elemente ermöglicht.\smfootcite[ vgl. ][]{Denicola2016} Die \emph{\ac{API}} beschreibt in diesem Zusammenhang eine Schnittstelle, welche einem anderen Programm ein Tool zur Verfügung stellt, um sich an das eigene Softwaresystem anbinden zu können.\smfootcite[ vgl.][]{Behrendt2016} Somit ermöglicht eine \emph{\ac{API}} einen Austausch von Informationen zwischen verschiedenen Programmen oder Systemen.	
			Die \emph{Custom Element \ac{API}} ermöglicht den Nutzern die Auszeichnungsprache \emph{\ac{HTML}} zu erweitern.\smfootcite[ vgl.][]{Argelius2016} Es können bestehende \emph{\ac{HTML}} Elemente erweitert, oder neue hinzugefügt werden. Jedes neue oder erweiterte Element wird unter einem \emph{Tag} Namen registriert. Dies ermöglicht eine Kapselung des erstellen Programmiercodes in Elemente. In Listing \ref{lst:cusEleJav} ist ein \emph{JavaScript} Programmcode dargestellt, welcher ein leeres \emph{Custom Element} definiert und und unter dem Namen \enquote{new-custom-element} registriert wird.
			\begin{listing}
				\begin{JavaScriptcode*}{}
class NewCustomElement extends HTMLElement {
	constructor() {
		super();
	}
}
customElements.define('new-custom-element', NewCustomElement);
				\end{JavaScriptcode*}
				\caption{Custom Element JavaScript}
				\label{lst:cusEleJav}
			\end{listing}
			Für \emph{Custom Elements} sind mehrere \emph{Callbacks} verfügbar. \emph{Callback} Funktionen beschreiben hier Funktionen, die bei bestimmten Ereignissen des \emph{Lifecycle} von außerhalb des \emph{Custom Elements} aufgerufen werden. Im folgenden werden diese Funktionen aufgelistet.\smfootcite[ vgl.][]{Argelius2016}
			\begin{description}  
				\item  [\emph{connectedCallback()}] Diese Funktion wird aufgerufen wenn das \emph{Custom Element} an den \emph{\ac{DOM}} angehängt wird.
				\item [\emph{disconnectedCallback()}] Diese Funktion wird aufgerufen, wenn das \emph{Custom Element} vom \emph{\ac{DOM}} wieder losgelöst wird. 
				\item  [\emph{attributeChangedCallback(name, prevValue, newValue)}] Diese Funktion wird aufgerufen, wenn sich ein Attribut ändert. Sie wird jedoch nur für Attribute aufgerufen, welche in einer statischen \emph{get} Funktion mit Namen \emph{observedAttributes} definiert wurden.
			\end{description}
			\subsection{HTML Imports}
			\emph{\ac{HTML} Imports} ist eine Technologie zum Importieren von externen \ac{HTML} Dokumenten in ein \ac{HTML} Dokument. Hier ist zu unterscheiden zwischen importierenden und importierten \ac{HTML} Dokumenten. Die importierenden Dokumente besitzen einen Link, welcher mindestens die \ac{URL} des \emph{Imports} und die Eigenschaft \emph{rel=\enquote{import}} besitzt,also ein Link eines bestimmten Typ ist, siehe Listing \ref{lst:htmImp}.\smfootcite[ vgl.][]{Glazkov2016} 
				\begin{listing}
				\begin{HTMLcode*}{}
 <link rel="import" href="/imports/imported-document.html">
				\end{HTMLcode*}
				\caption{Standard HTML Import}
				\label{lst:htmImp}
				\end{listing}
			Die importierten Dokumente haben keinen außergewöhnlichen Aufbau im Vergleich zu normalen \ac{HTML} Dokumenten, sie können aus \ac{HTML}, \emph{Style} oder \emph{Script} Elementen bestehen. Es kann auch die \emph{Template} Technologie verwendet werden, dazu mehr in \ref{subsec:Templates}.
			Um auf den Inhalt des importierten Dokuments zuzugreifen wird \emph{JavaScript} verwendet. Wie in Listing \ref{lst:htmImpJav} dargestellt, wird zuerst nach dem Link Element gesucht, welches die Eigenschaft \emph{rel=\enquote{import}} besitzt. Daraufhin wird dieses Dokument importiert und ein bestimmter Teil des Dokuments als \emph{JavaScript} Variable \emph{\enquote{elemt}} gespeichert. Hier wird ein \ac{div} Element, welches die Klasse \emph{\enquote{element}} besitzt gespeichert. Dieses kann dann in der importierenden Seite genutzt werden. 
			\begin{listing}
			\begin{JavaScriptcode*}{}
var link = document.querySelector('link[rel=import]');
var importedDocument = link.import;
var elem = importedDocument.querySelector('div.element');
			\end{JavaScriptcode*}
			\caption{JavaScript Code für Zugriff auf Inhalt des importierten Dokuments}
			\label{lst:htmImpJav}
			\end{listing} 
			
			\subsection{Templates}
			\label{subsec:Templates}
			Das \ac{HTML5} Feature \emph{Templates} ermöglicht Teile einer Seite unabhängig vom \ac{DOM} zu erstellen. Diese können dann später programmatisch zum \ac{DOM} hinzugefügt werden.\smfootcite[ vgl.][ S. 177]{Cameron2015} Dies bedeutet, dass der Inhalt des \emph{Templates}, bis er zum \ac{DOM} hinzugefügt wird, nicht in der Webanwendung angezeigt wird und auch nicht über \ac{DOM} Selektoren angesteuert werden kann. Gegebenenfalls im \emph{Template} enthaltene Bilder werden nicht geladen und Skripte nicht ausgeführt.\smfootcite[ vgl.][]{Potschien2013} 
			\begin{listing}
				\begin{JavaScriptcode*}{}
var inhalt = document.querySelector("template").content;
document.querySelector("body").appendChild(inhalt);
				\end{JavaScriptcode*}
				\caption{JavaScript Code für das Hinzufügen eines Templates in das DOM}
				\label{lst:htmTem}
			\end{listing}
			In \ref{lst:htmTem} sieht man den \emph{JavaScript} Code um ein vorhandenes \emph{Template} zum \ac{DOM} hinzuzufügen. In Zeile eins wird der Inhalt des \emph{Templates} zur \emph{JavaScript} Variable \enquote{inhalt} hinzugefügt, um dann in der nächsten Zeile an den \emph{Body} der Seite, also dem Inhalt hinzugefügt zu werden. In diesem Moment werden auch die Bilder des \emph{Templates} geladen und eventuelle Skripte ausgeführt.
			\subsection{Shadow DOM !SLOTS!}
			\enquote{Das \emph{Shadow \ac{DOM}} beschreibt die Fähigkeit eines Browsers, eine neue, völlig abgekapselte Knotenstruktur im bestehenden \ac{DOM} zu erzeugen.}\smfootcite[ ][Kap. 11.1.4]{gasston2014moderne} Dies bedeutet, dass neben dem normalen \emph{Document tree}, wessen Wurzelknoten ein Dokument ist, noch der \emph{Shadow tree} besteht. Der Wurzelknoten des letzteren ist kein Dokument, sondern der \emph{Shadow root}. Dies ist in Abbildung \ref{img:shaDom} dargestellt.\smfootcite[ vgl.][S. 22]{patel2015learning} 
			\begin{figure}[ht]
				\centering
				\includegraphics{shaDom.png}
				\caption{DOM und Shadow \ac{DOM} }
				\label{img:shaDom}
			\end{figure}
			Die Folge dieser Kapselung ist, dass alles was dem \emph{Shadow tree} hinzugefügt wird, nur lokal Einfluss auf diesen hat. Die Gestaltung von Webelementen im \emph{Shadow root} wird dadurch vereinfacht.
			\ac{CSS} Selektoren können nicht von außerhalb des \emph{Shadow roots} auf diesen zugreifen und Selektoren, die innerhalb dieses definiert werden haben keinen Einfluss auf den normalen \ac{DOM}. Genauso verhält es sich mit dem Zugriff auf die \ac{DOM} Elemente des \emph{Shadow root}. Sie können nicht von außerhalb angesprochen werden, beispielsweise durch die Funktion \emph{document.querySelector()}, sondern können nur von Funktionen innerhalb des \emph{Shadow root} angesprochen werden.\smfootcite{Bidelman2016}
			\begin{listing}
				\begin{JavaScriptcode*}{}
var header = document.createElement('header');
var shadowRoot = header.attachShadow({mode: 'open'});
var headline = document.createElement("h1");
var headlineText = document.createTextNode("headline");
headline.appendChild(headlineText);
shadowRoot.appendChild(headline);
				\end{JavaScriptcode*}
				\caption{JavaScript Code für das Erstellen eines Shadow DOM}
				\label{lst:javShaDom}
			\end{listing}
			In Listing \ref{lst:javShaDom} ist dargestellt, wie Mithilfe von JavaScript ein \emph{Shadow \ac{DOM}} erstellt wird. In Zeile zwei wird zuerst einem bestehendem Element ein \emph{Shadow root} hinzugefügt. Daraufhin wird eine Überschrift und deren Text erstellt und zusammengefügt. Zuletzt wird in Zeile sechs die Überschrift in den \emph{Shadow \ac{DOM}} eingefügt.
			\subsubsection{Slots}
			\emph{Shadow \ac{DOM}} kann auch mit anderen \ac{DOM} erweitert werden. Der Entwickler kann dem Nutzer seines \emph{Web Component} ermöglichen, diesen zu erweitern. Hierfür werden \emph{Slots} verwendet. 
			\begin{listing}
			\begin{HTMLcode*}{}
<ul id="contacts">
   <li>
      <slot name="name">
         <p>Achtung<p>
         <h1>Kein Name<h1>
      </slot>
      <slot name="title">Kein Titel</slot>
   </li>
</ul>
			\end{HTMLcode*}
			\caption{Nutzung von Slot im Shadow DOM}
			\label{lst:sloNutShaDom}
			\end{listing}
			In Listing \ref{lst:sloNutShaDom} ist der \ac{HTML} Programmcode des \emph{Web Component} dargestellt, welcher im \emph{Shadow \ac{DOM}} später gerendert wird. Hier ist die Verwendung des \emph{Slot} Elements interessant. Dieses kann beim Einbinden des \emph{Web Component} später ausgestattet werden. Wird das Platzhalter-Element später nicht befüllt, wird das \emph{Fallback}, der Inhalt innerhalb des Elements, hier beispielsweise \enquote{Kein Titel} genutzt. Das \emph{Fallback} kann auch aus einem eigenen \ac{DOM} Baum bestehen, wie im \emph{Slot} \enquote{name} zu sehen ist.\smfootcite{Bidelman2016} In Listing \ref{lst:sloNutLigDom} werden die, in Listing \ref{lst:sloNutShaDom} erstellten Platzhalter-Elemente, beim Verwenden des \emph{Web Component} in beispielsweise einer Webseite befüllt. Wie hier in Zeile zwei und drei zu sehen ist, können einzelne Slots auch mit mehreren Elementen befüllt werden. Beim rendern der Applikation werden alle Elemente, welche die passenden \emph{Slot} Attribute aufweisen in den \ac{DOM} gerendert. Wenn im \emph{Shadow \ac{DOM}} ein \emph{Slot} Platzhalter ohne ein \enquote{name} Attribut definiert wird, werden alle vom Nutzer innerhalb des \emph{Web Components} erstellten Elemente in den \emph{DOM} geschrieben.
			\begin{listing}
				\begin{HTMLcode*}{}
<span slot="name">Michael</span>
<span slot="title">Dr.</span>
<span slot="title">Phil.</span>
				\end{HTMLcode*}
				\caption{Befüllen des Slots im DOM}
				\label{lst:sloNutLigDom}
			\end{listing} 
	\chapter{Methodik dieser Arbeit}
	\chapter{Adaptive Web Components}
		\section{Identifikation passender Web Components}
			\subsection{Identifikation Web Components}
			\subsection{Identifikation passender Preference Terms}
		\section{Preference Sets zur Adaptivität}
		\section{Adaptivität der bestehenden Web Components}
			\subsection{Web Component Eins}
				\subsubsection{Konzeption zur Adaptivität}
				\subsubsection{Umsetzung Programmierung}
			\subsection{Web Component Zwei}
			\subsection{Web Component Drei}
	\chapter{Vergleich}
		\section{Vergleich mit Polymer}

	\printbibliography

\end{document}